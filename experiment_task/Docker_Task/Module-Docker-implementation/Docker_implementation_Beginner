=> Containers Concepts
-> Containers are "a form of operating system virtualization". A single container might be used to run anything from a small microservice or software process to a larger application. Inside a container are all the necessary executables, binary code, libraries, and configuration files.

=> Docker installation
-> Command to install latest version of docker on Ubuntu

# sudo apt-get update
# sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
$ docker --version

=> Describe Dockerfile options [add, copy, volumes, expose, entrypoint, etc)

-> COPY takes in a source and destination. It only lets you copy in a local or directory from your host into the Docker image itself.
e.g: 
Syntax: COPY <src> <dest>
COPY testfile1 /tmp


-> ADD  does that same but in addition, it also supports :
- Extract tar from the source directory into the destination.
e.g: 
Syntax: ADD <src> <dest>
ADD testfile1 /tmp
ADD test.tar.gz /tmp

-> Volume : Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. 
e.g:
VOLUME /myvolume
Note: This volume can be used by other container too.

$ docker volume ls
$ docker volume inspect volume_name/id
$ docker volume rm [volume_name]

To delete all unused Docker volumes with a single command:
$ docker volume prune

-> expose: A Dockerfile tells Docker that a container listens for traffic on the specified port. 
Syntax: EXPOSE <port>/<protocol>

-> ENTRYPOINT : The ENTRYPOINT instruction is used to configure the executables that will always run after the container is initiated. For example, you can mention a script to run as soon as the container is started.
e.g:
ENTRYPOINT ["/script.sh"]
ENTRYPOINT echo "Hello World" (shell form)
ENTRYPOINT ["echo", "Hello World"] (exec form)


=> Show the main parts of a Dockerfile
-> Dockerfile is basically a text file. It contains some set of instructions.

FROM 
COPY 
ENTRYPOINT 

From above all these 3 command, important is "FROM". Because it is taking basic image from docker registry.

=> Give examples on how to create an efficient image via a Dockerfile
-> Write a "Dockerfile" with our required framwork and command. Which we will get from developers. And with source code. Then build that docker file with a tag name.
$ docker build -t required_image_name .
Note: Here, 
           "." is representing docker file location.


=> Use CLI commands such as list, delete, prune, rmi, etc to manage images

-> Command to list docker images:
$ docker image ls

-> Command to delete docker images:
$ docker rmi Image 

-> Command to delete all unused images:
$ docker image prune

-> Inspect images and report specific attributes using filter and format


-> This command will show all image "ID", "RepoTag" and "Architecture"
$ docker image inspect --format "{{.ID}} {{.RepoTags}} {{.Architecture}}" $(docker image ls -q)

$ docker image inspect --format "{{.ID}} {{.RepoTags}} {{.Architecture}}" $(docker images test-1)

$ docker image inspect image_id
$ docker inspect --type image test-1

Note: 
Specify target type (--type)ðŸ”—
--type container|image|node|network|secret|service|volume|task|plugin


=> Demonstrate tagging an image

-> Docker tags are just an alias for an image ID. The tag's name must be an ASCII character string and may include lowercase and uppercase letters, digits, underscores, periods, and dashes. 
The name of the Docker image maximum length is 4096 characters.

=> Push an image to a registry

$ docker login (Login in docker hub or in your AWS/Azure registry)
$ docker build -t docker_tag_name .
e.g:
$ docker build -t test-1 .
$ docker image ls
Now, 
my_tag_name = test-1
username = subodhkumar321

Create an image tag as per your registry or your username in dockerhub.
$ docker tag my_tag_name username/my_tag_name
$docker tag test-1 subodhkumar321/test-1

Command to push in dockerhub:

$ docker push subodhkumar321/test-1
 

=> Pull an image from a registry\

$ docker push subodhkumar321/test-1